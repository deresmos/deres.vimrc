[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp'

[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp-signature-help'
on_lua = ['lsp_signature']

[[plugins]]
repo = 'ray-x/lsp_signature.nvim'
on_lua = ['lsp_signature']

[[plugins]]
repo = 'mfussenegger/nvim-dap'
hook_add = '''
nmap <silent> <SPACE>mdc <cmd>lua require'dap'.continue()<CR>
nmap <silent> <SPACE>mdC <cmd>lua require'dap'.run_last()<CR>
nmap <silent> <SPACE>mdq <cmd>lua require'dap'.stop()<CR>
" nmap <silent> <SPACE>mdR <Plug>VimspectorRestart
" nmap <silent> <SPACE>mdc <Plug>VimspectorPause
nmap <silent> <SPACE>mdp <cmd>lua require'dap'.toggle_breakpoint()<CR>
nmap <silent> <SPACE>mdP <cmd>lua require'dap.breakpoints'.clear()<CR>
" nmap <silent> <SPACE>mdc <Plug>VimspectorAddFunctionBreakpoint
nmap <silent> <SPACE>mdn <cmd>lua require'dap'.step_over()<CR>
nmap <silent> <SPACE>mdi <cmd>lua require'dap'.step_into()<CR>
nmap <silent> <SPACE>mdo <cmd>lua require'dap'.step_out()<CR>
nmap <silent> <SPACE>mdb <cmd>lua require'dap'.step_back()<CR>

nmap <silent> <SPACE>mdu <cmd>lua require'dap'.up()<CR>
nmap <silent> <SPACE>mdd <cmd>lua require'dap'.down()<CR>
nmap <silent> <SPACE>mdl <cmd>lua require'dap'.list_breakpoints()<CR>

" nnoremap <silent> <SPACE>mdw :<C-u>execute 'VimspectorWatch' expand('<cword>')<CR>
" xnoremap <silent> <SPACE>mdw :<C-u>execute 'VimspectorWatch' GetVisualWord()<CR>

nnoremap <silent> <SPACE>mdf <cmd>lua Dap.run_file()<CR>
nnoremap <silent> <SPACE>mdt <cmd>lua Dap.run_test()<CR>
nnoremap <silent> <SPACE>mdm <cmd>lua Dap.run_test_nearest()<CR>

nnoremap <silent> <SPACE>mdQ <cmd>call <SID>dapTerminate()<CR>

nnoremap <silent> <SPACE>mdT <cmd>lua require'dapui'.toggle()<CR>
nnoremap <silent> <SPACE>mdF <cmd>call <SID>openFloatWin()<CR>

function! s:dapTerminate() abort
  lua require'dap'.terminate()
  lua require'dapui'.close()
  lua require'nvim-dap-virtual-text'.refresh()
  tabclose
endfunction

function! s:openFloatWin() abort
lua << EOF
  local filetype = vim.bo.filetype
  local name = filetype:gsub("dapui_", "")
  for i, value in ipairs({"scopes", "watches", "breakpoints", "stacks", "repl"}) do
    if name == value then
      require'dapui'.float_element(name, {enter=true})
      break
    end
  end
EOF
endfunction


lua << EOF
  local dap = require('dap')
  dap.listeners.before['event_initialized']['custom'] = function(session, body)
    vim.cmd('tabedit')
    require'dapui'.open()
  end

  dap.listeners.before['event_terminated']['custom'] = function(session, body)
    print('Session terminated')
    require'dapui'.close()
    require'nvim-dap-virtual-text'.refresh()
    vim.cmd('tabclose')
  end

  Dap = {}

  Dap.configuration = {
    go_file={
      type = "go",
      name = "Debug file",
      request = "launch",
      program = "${file}",
    },
    go_test_file={
      type = "go",
      name = "Debug test file",
      request = "launch",
      mode = "test",
      program = "${file}",
    },
    go_test={
      type = "go",
      name = "Debug test suite",
      request = "launch",
      mode = "test",
      program = "./${relativeFileDirname}",
    },
    go_test_nearest = function()
      require'dap-go'.debug_test()
    end,
  }

  function Dap.run(run_type)
    local filetype = vim.bo.filetype
    local configuration = Dap.configuration[filetype .. "_" .. run_type]
    if not configuration then
      print("This filetype is not supported.")
      return
    end

    if type(configuration) == 'function' then
      configuration()
    else
      require'dap'.run(configuration)
    end
  end

  function Dap.run_file()
    Dap.run("file")
  end

  function Dap.run_test()
    Dap.run("test")
  end

  function Dap.run_test_file()
    Dap.run("test_file")
  end

  function Dap.run_test_nearest()
    Dap.run("test_nearest")
  end
EOF
'''

[[plugins]]
repo = 'leoluz/nvim-dap-go'
hook_add = '''
lua require('dap-go').setup()

lua << EOF
  local dap = require('dap')
  dap.configurations.go = {
    {
      type = "go",
      name = "Debug",
      request = "launch",
      program = "${file}",
    },
    {
      type = "go",
      name = "Debug file",
      request = "launch",
      mode = "test",
      program = "${file}",
    },
    {
      type = "go",
      name = "Debug test suite",
      request = "launch",
      mode = "test",
      program = "${workspaceFolder}",
    } 
  }

EOF
'''

[[plugins]]
repo = 'mfussenegger/nvim-dap-python'
hook_add = '''
lua << EOF
require('dap-python').setup('python')
EOF
'''

[[plugins]]
repo = 'rcarriga/nvim-dap-ui'
hook_add = '''
lua << EOF
require("dapui").setup({
  icons = { expanded = "▾", collapsed = "▸" },
  mappings = {
    expand = { "<CR>", "<C-m>" },
    open = "o",
    remove = "d",
    edit = "e",
    repl = "r",
  },
  sidebar = {
    -- You can change the order of elements in the sidebar
    elements = {
      -- Provide as ID strings or tables with "id" and "size" keys
      {
        id = "scopes",
        size = 0.35, -- Can be float or integer > 1
      },
      { id = "watches", size = 0.25 },
      { id = "stacks", size = 0.25 },
      { id = "breakpoints", size = 0.15 },
    },
    size = 55,
    position = "left", -- Can be "left", "right", "top", "bottom"
  },
  tray = {
    elements = { "repl" },
    size = 10,
    position = "bottom", -- Can be "left", "right", "top", "bottom"
  },
  floating = {
    max_height = nil, -- These can be integers or a float between 0 and 1.
    max_width = nil, -- Floats will be treated as percentage of your screen.
    border = "single", -- Border style. Can be "single", "double" or "rounded"
    mappings = {
      close = { "q", "<Esc>" },
    },
  },
  windows = { indent = 1 },
})


vim.fn.sign_define('DapBreakpoint', {text='●', texthl='GitGutterDelete', linehl='', numhl=''})
vim.fn.sign_define('DapStopped', {text='▶', texthl='GitGutterAdd', linehl='', numhl=''})

EOF
'''

[[plugins]]
repo = 'theHamsta/nvim-dap-virtual-text'
hook_add = '''
lua << EOF
require("nvim-dap-virtual-text").setup {
    enabled = true,                     -- enable this plugin (the default)
    enabled_commands = true,            -- create commands DapVirtualTextEnable, DapVirtualTextDisable, DapVirtualTextToggle, (DapVirtualTextForceRefresh for refreshing when debug adapter did not notify its termination)
    highlight_changed_variables = true, -- highlight changed values with NvimDapVirtualTextChanged, else always NvimDapVirtualText
    highlight_new_as_changed = false,   -- highlight new variables in the same way as changed variables (if highlight_changed_variables)
    show_stop_reason = true,            -- show stop reason when stopped for exceptions
    commented = false,                  -- prefix virtual text with comment string
    -- experimental features:
    virt_text_pos = 'eol',              -- position of virtual text, see `:h nvim_buf_set_extmark()`
    all_frames = false,                 -- show virtual text for all stack frames not only current. Only works for debugpy on my machine.
    virt_lines = false,                 -- show virtual lines instead of virtual text (will flicker!)
    virt_text_win_col = nil             -- position the virtual text at a fixed window column (starting from the first text column) ,
                                        -- e.g. 80 to position at column 80, see `:h nvim_buf_set_extmark()`
}
EOF
'''

[[plugins]]
repo = 'AndrewRadev/linediff.vim'
hook_add = '''
xnoremap <silent> <SPACE>ld <cmd>Linediff<CR>
'''

[[plugins]]
repo = 'will133/vim-dirdiff'
rev = '7d588e7658d8a643241a379fe5bbd22071025090'

[[plugins]]
repo = 'skywind3000/asyncrun.vim'
hook_add = '''
nnoremap <silent> <SPACE>gPs :<C-u>AsyncRun -cwd=<root> git push -v origin HEAD<CR>
nnoremap <silent> <SPACE>gPl :<C-u>AsyncRun -cwd=<root> git pull origin HEAD<CR>
nnoremap <silent> <SPACE>gPL :<C-u>AsyncRun -cwd=<root> git pull --all<CR>
nnoremap <silent> <SPACE>gPf :<C-u>AsyncRun -cwd=<root> git fetch<CR>

function! s:asyncrun_after()
  let defualt_cmd = 'copen | wincmd p'
  let cmd = get(b:, 'asyncrun_after_cmd', v:null)
  if cmd == v:null
    let cmd = defualt_cmd
  endif

  execute cmd

  " Reset asyncrun_after_cmd
  if exists('b:asyncrun_after_cmd')
    unlet b:asyncrun_after_cmd
  endif
endfunction

augroup custom-asyncrun
  autocmd!
  autocmd User AsyncRunStart highlight! LightlineMiddle_active ctermbg=34
  autocmd User AsyncRunStop highlight! link LightlineMiddle_active LightlineMiddle_normal | call s:asyncrun_after()
augroup END
'''

[[plugins]]
repo = 'Shougo/dein.vim'
hook_add = '''
  let g:dein#auto_recache = v:true
'''

[[plugins]]
repo = 'lewis6991/impatient.nvim'
hook_add = '''
lua require'impatient'
'''

[[plugins]]
repo = 'EdenEast/nightfox.nvim'
hook_add = '''
colorscheme nightfox
'''

[[plugins]]
repo = 'deresmos/nvim-term'
hook_add = '''
  let g:nvimterm#toggle_size = 30
  let g:nvimterm#enter_insert = 0

  function! s:terminal_keymap() abort
    nnoremap <buffer> I i<C-a>
    nnoremap <buffer> A a<C-e>
    nnoremap <buffer> dd i<C-e><C-u><C-\><C-n>
    nnoremap <buffer> cc i<C-e><C-u>
    nnoremap <buffer> q :<C-u>close<CR>
  endfunction

  augroup nvim-term-custom
    autocmd!
    autocmd FileType nvim-term,nvim-term-t call s:terminal_keymap()
  augroup END

  nnoremap <silent> <SPACE>ts :NTermS<CR>
  nnoremap <silent> <SPACE>tv :NTermV<CR>
  nnoremap <silent> <SPACE>tt :NTermT<CR>
  nnoremap <silent> <SPACE>te :NTerm<CR>
'''

[[plugins]]
repo = 'kyazdani42/nvim-web-devicons'

[[plugins]]
repo = 'nvim-lua/plenary.nvim'

[[plugins]]
repo = 'fuenor/qfixhowm'
hook_add = '''

  " functions {{{
  function! s:HowmEditDiary(filename) abort
    tabnew
    call qfixmemo#EditDiary(a:filename)
  endfunction

  function! s:pullHowm() abort
    execute 'AsyncRun -cwd=' . g:QFixHowm_RootDir 'git pull origin master'
  endfunction

  function! s:pushHowm() abort
    execute 'AsyncRun -cwd=' . g:QFixHowm_RootDir ' git add . && git commit -m "commit" && git push origin master'
  endfunction

  function! QFixMemoBufRead()
    setlocal foldenable
  endfunction

  " }}}

  " map {{{
  nnoremap <silent> <SPACE>hc :<C-u>call qfixmemo#Calendar()<CR>
  nnoremap <silent> <SPACE>hm :<C-u>call <SID>HowmEditDiary('memo')<CR>
  nnoremap <silent> <SPACE>hs :<C-u>call <SID>HowmEditDiary('schedule')<CR>
  nnoremap <silent> <SPACE>ht :<C-u>call <SID>HowmEditDiary(g:qfixmemo_diary)<CR>
  nnoremap <silent> <SPACE>hf :<C-u>call <SID>HowmEditDiary('filetype/' . &filetype)<CR>
  nnoremap <silent> <SPACE>ho :<C-u>call <SID>HowmEditDiary('memo/'.input('Name: '))<CR>
  nnoremap <silent> <SPACE>hlo :Denite file -path=`g:howm_dir`/memo<CR>
  nnoremap <silent> <SPACE>hg :<C-u>call qfixmemo#FGrep()<CR>
  nnoremap <silent> <SPACE>ha :<C-u>call qfixmemo#PairFile('%')<CR>
  nnoremap <silent> <SPACE>hid :<C-u>call qfixmemo#InsertDate('date')<CR>
  nnoremap <silent> <SPACE>hit :<C-u>call qfixmemo#InsertDate('time')<CR>
  nnoremap <silent> <SPACE>hlr :<C-u>call qfixmemo#ListMru()<CR>
  nnoremap <silent> <SPACE>hlt :<C-u>call qfixmemo#ListReminder('todo')<CR>
  nnoremap <silent> <SPACE>hls :<C-u>call qfixmemo#ListReminder('schedule')<CR>
  nnoremap <silent> <SPACE>hlc :<C-u>call qfixmemo#ListFile(g:qfixmemo_diary)<CR>
  nnoremap <silent> <SPACE>hlf :<C-u>call qfixmemo#ListFile('filetype/*')<CR>
  nnoremap <silent> <SPACE>hlw :<C-u>call qfixmemo#ListFile('wiki/*')<CR>
  nnoremap <silent> <SPACE>hll :<C-u>call qfixmemo#ListRecentTimeStamp()<CR>

  command! -nargs=1 HowmDir let g:howm_dir = g:QFixHowm_RootDir.'/'.<q-args>|echo 'Switched' <q-args>
  nnoremap <silent> <SPACE>hpw :<C-u>HowmDir work<CR>
  nnoremap <silent> <SPACE>hpm :<C-u>HowmDir main<CR>
  nnoremap <silent> <SPACE>hpl :<C-u>call <SID>pullHowm()<CR>
  nnoremap <silent> <SPACE>hps :<C-u>call <SID>pushHowm()<CR>
  " }}}

  let g:QFixHowm_MenuKey        = 0
  let g:QFixHowm_Key            = '<Nop>'
  let g:howm_fileencoding       = 'utf-8'
  let g:howm_fileformat         = 'unix'
  let g:qfixmemo_diary          = '%Y/%m/%Y-%m-%d'
  let g:QFixHowm_CalendarWinCmd = 'rightbelow'
  let g:QFixHowm_CalendarCount  = 3
  let g:QFixHowm_FileType       = 'qfix_memo'
  let g:qfixmemo_template       = ['%TITLE% ']
  let g:qfixmemo_use_addtime    = 0
  let g:qfixmemo_use_updatetime = 0
  let g:QFixHowm_SaveTime       = -1
  let g:QFixHowm_Wiki           = 1
  let g:QFixHowm_WikiDir        = 'wiki'
  let g:QFixHowm_Menufile       = 'menu.howm'
  let g:QFixHowm_MenuCloseOnJump = 1

  let g:QFixHowm_RootDir         = '~/.howm'
  let g:howm_dir                 = g:QFixHowm_RootDir . '/main'
  let g:qfixmemo_folding_pattern = '^=[^=]'
'''

[[plugins]]
repo = 'akinsho/toggleterm.nvim'
hook_add = '''
nnoremap <silent> <SPACE>to :ToggleTerm direction=horizontal size=20<CR>
nnoremap <silent> <SPACE>tf :ToggleTerm direction=float size=20<CR>

function! s:setup_term() abort
  nnoremap <buffer> I i<C-a>
  nnoremap <buffer> A a<C-e>
  nnoremap <buffer> dd i<C-e><C-u><C-\><C-n>
  nnoremap <buffer> cc i<C-e><C-u>
  nnoremap <buffer> q :<C-u>quit<CR>
endfunction

augroup term-custom
  autocmd!
  autocmd TermOpen term://* call s:setup_term()
augroup END

lua << EOF
require("toggleterm").setup{
  size = function(term)
    if term.direction == "horizontal" then
      return 20
    elseif term.direction == "vertical" then
      return vim.o.columns * 0.4
    end
  end,
  -- open_mapping = [[<c-\>]],
  -- hide_numbers = true,
  shade_filetypes = {},
  shade_terminals = true,
  start_in_insert = true,
  insert_mappings = true,
  persist_size = true,
  direction = 'horizontal',
  close_on_exit = false,
  shell = vim.o.shell,
  float_opts = {
    border = 'curved',
    highlights = {
      border = "Normal",
      background = "Normal",
    },
  },
}
EOF
'''

[[plugins]]
repo = 'mbbill/undotree'
hook_add = '''
nnoremap <silent> <SPACE>udt <cmd>UndotreeToggle<CR>
'''

[[plugins]]
repo = 'schickling/vim-bufonly'
hook_add = '''
nnoremap <silent> <SPACE>bO <cmd>BufOnly!<CR>
'''

[[plugins]]
repo = 'RRethy/vim-illuminate'

[[plugins]]
repo = 'deresmos/vim-spatab'
hook_add = '''
  let g:spatab_count_mode = 1

  augroup vim-spatab
    autocmd!
    autocmd BufReadPost * STDetect
  augroup END
'''

[[plugins]]
repo = '~/.fzf'

[[plugins]]
repo = 'junegunn/fzf.vim'

[[plugins]]
repo = 'francoiscabrol/ranger.vim'
hook_add = '''
  let g:ranger_replace_netrw = 0
  nnoremap <silent> <SPACE>ra :RangerCurrentFile<CR>
  nnoremap <silent> <SPACE>rA :RangerWorkingDirectory<CR>
'''

[[plugins]]
repo = 'nvim-telescope/telescope-file-browser.nvim'
on_lua = ['telescope']

[[plugins]]
repo = 'nvim-telescope/telescope.nvim'
on_lua = ['telescope']
hook_add = '''
lua << EOF
  local actions = require("telescope.actions")
  local fb_actions = require("telescope").extensions.file_browser.actions

  require('telescope').setup{
    defaults = {
      cache_picker = {
        num_pickers = 10,
      },
      vimgrep_arguments = {
        'rg',
        '--color=never',
        '--no-heading',
        '--with-filename',
        '--line-number',
        '--column',
        '--smart-case'
      },
      prompt_prefix = "> ",
      selection_caret = "> ",
      entry_prefix = "  ",
      initial_mode = "insert",
      selection_strategy = "reset",
      scroll_strategy = "limit",
      sorting_strategy = "ascending",
      layout_strategy = "vertical",
      layout_config = {
        horizontal = {
          mirror = false,
          prompt_position = "top",
        },
        vertical = {
          mirror = true,
          width = 0.7,
          prompt_position = "top",
        },
      },
      file_sorter =  require'telescope.sorters'.get_fzy_sorter,
      file_ignore_patterns = {},
      generic_sorter =  require'telescope.sorters'.get_fzy_sorter,
      winblend = 0,
      border = {},
      borderchars = { '─', '│', '─', '│', '╭', '╮', '╯', '╰' },
      color_devicons = true,
      use_less = true,
      set_env = { ['COLORTERM'] = 'truecolor' }, -- default = nil,
      file_previewer = require'telescope.previewers'.vim_buffer_cat.new,
      grep_previewer = require'telescope.previewers'.vim_buffer_vimgrep.new,
      qflist_previewer = require'telescope.previewers'.vim_buffer_qflist.new,
      buffer_previewer_maker = require'telescope.previewers'.buffer_previewer_maker,
      mappings = {
        i = {
          ["<C-u>"] = false,
          ["<C-Up>"] = actions.cycle_history_prev,
          ["<C-Down>"] = actions.cycle_history_next,
        },
        n = {
          ["q"] = actions.close,
          ["v"] = actions.select_vertical,
          ["s"] = actions.select_horizontal,
          ["t"] = actions.select_tab,
          ["<C-u>"] = actions.preview_scrolling_up,
          ["<C-d>"] = actions.preview_scrolling_down,
          ["<C-p>"] = require'telescope.actions.layout'.toggle_preview,
        },
      },
    },
    extensions = {
      file_browser = {
        mappings = {
          ["i"] = {
            ["<C-h>"] = fb_actions.goto_parent_dir, 
          },
          ["n"] = {
            ["l"] = actions.select_default,
            ["h"] = fb_actions.goto_parent_dir,
          },
        },
      },
    },
  }

  require("telescope").load_extension("file_browser")
EOF

nnoremap <silent> <SPACE>ff <cmd>lua require'telescope.builtin'.find_files()<CR>
nnoremap <silent> <SPACE>bf <cmd>lua require'telescope.builtin'.find_files({cwd = vim.fn.expand('%:p:h')})<CR>
nnoremap <silent> <SPACE>pf <cmd>lua require'telescope.builtin'.git_files()<CR>

nnoremap <silent> <SPACE>fg <cmd>lua require'telescope.builtin'.live_grep()<CR>
nnoremap <silent> <SPACE>pg <cmd>lua require'telescope.builtin'.live_grep()<CR>
nnoremap <silent> <SPACE>fr <cmd>lua require'telescope.builtin'.resume()<CR>
'''

[[plugins]]
repo = 'lambdalisue/gina.vim'

[[plugins]]
repo = 'ruifm/gitlinker.nvim'
hook_add = '''
lua << EOF
require'gitlinker'.setup({
  opts = {
    remote = nil,
    add_current_line_on_normal_mode = true,
    action_callback = require'gitlinker.actions'.copy_to_clipboard,
    print_url = true,
  },
  callbacks = {
        ['github.com'] = require'gitlinker.hosts'.get_github_type_url,
        ['bitbucket.org'] = require'gitlinker.hosts'.get_bitbucket_type_url,

  },
  mappings = '<leader>gy'
})
EOF
'''

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
hook_add = '''
nnoremap <silent> <SPACE>gk <cmd>lua require'gitsigns.actions'.prev_hunk()<CR>
nnoremap <silent> <SPACE>gj <cmd>lua require'gitsigns.actions'.next_hunk()<CR>
nnoremap <silent> <SPACE>gp <cmd>lua require'gitsigns'.preview_hunk()<CR>
nnoremap <silent> <SPACE>gu <Nop>
nnoremap <silent> <SPACE>gU <cmd>lua require'gitsigns'.reset_hunk()<CR>
xnoremap <silent> <SPACE>gU <cmd>lua require'gitsigns'.reset_hunk({vim.fn.line("."), vim.fn.line("v")})<CR>
nnoremap <silent> <SPACE>ga <Nop>
nnoremap <silent> <SPACE>gA <cmd>lua require'gitsigns'.stage_hunk()<CR>
xnoremap <silent> <SPACE>gA <cmd>lua require'gitsigns'.stage_hunk({vim.fn.line("."), vim.fn.line("v")})<CR>
nnoremap <silent> <SPACE>gtt <cmd>lua require'gitsigns'.toggle_signs()<CR>

lua << EOF
  require('gitsigns').setup {
    -- signs = {
    --   add          = {hl = 'GitSignsAdd'   , text = '│', numhl='GitSignsAddNr'   , linehl='GitSignsAddLn'},
    --   change       = {hl = 'GitSignsChange', text = '│', numhl='GitSignsChangeNr', linehl='GitSignsChangeLn'},
    --   delete       = {hl = 'GitSignsDelete', text = '__', numhl='GitSignsDeleteNr', linehl='GitSignsDeleteLn'},
    --   topdelete    = {hl = 'GitSignsDelete', text = '‾‾', numhl='GitSignsDeleteNr', linehl='GitSignsDeleteLn'},
    --   changedelete = {hl = 'GitSignsChange', text = '~', numhl='GitSignsChangeNr', linehl='GitSignsChangeLn'},
    -- },
    signcolumn = true,
    numhl      = false,
    linehl     = false,
    keymaps = {},
    watch_gitdir = {
      interval = 1000,
      follow_files = true
    },
    attach_to_untracked = true,
    current_line_blame = false,
    current_line_blame_opts = {
      virt_text = true,
      virt_text_pos = 'eol',
      delay = 1000,
    },
    current_line_blame_formatter_opts = {
      relative_time = false
    },
    sign_priority = 6,
    update_debounce = 100,
    status_formatter = function(status)
      local added, changed, removed = status.added, status.changed, status.removed
      local status_txt = {}
      if added   and added   > 0 then
        table.insert(status_txt, '%#GitSignsAdd#+'..added)
      end
      if changed and changed > 0 then
        table.insert(status_txt, '%#GitSignsChange#~'..changed)
      end
      if removed and removed > 0 then
        table.insert(status_txt, '%#GitSignsDelete#-'..removed)
      end
      return table.concat(status_txt, ' ')
    end,
    max_file_length = 10000,
    preview_config = {
      border = 'single',
      style = 'minimal',
      relative = 'cursor',
      row = 0,
      col = 1
    },
    diff_opts = {
      internal = true,
    },
    word_diff = false,
    yadm = {
      enable = false
    },
  }
EOF
'''

[[plugins]]
repo = 'tpope/vim-fugitive'
hook_add = '''
function! FugitiveCommitError(error, tmpfile)
  if a:error =~? 'pre-commit'
    call s:applyQflist(a:tmpfile)
  endif
endfunction

function! s:applyQflist(tmpfile)
  let errors = []
  let contents = readfile(a:tmpfile)

  let filepath = ''
  for content in contents
    if empty(content)
      continue
    endif

    if content =~? '^/' && filereadable(content)
      let filepath = content
      continue
    endif

    if content =~? '\v\s*[0-9]+:[0-9]+'
      let csp = split(content)
      call add(errors, filepath . ':' . csp[0] . ':' . join(csp[2:-2], ' ') . '. [' . csp[-1] . ']')
    endif
  endfor

  setlocal errorformat=%f:%l:%c:%m
  cgetexpr join(errors, "\n")
  q
  copen
endfunction

nnoremap <silent> <SPACE>gs <cmd>Git<CR>
nnoremap <silent> <SPACE>gv <cmd>Gvdiff<CR>
nnoremap <silent> <SPACE>gb <cmd>Git blame<CR>
'''

[plugins.ftplugin]
fugitive = '''
  nmap <buffer> <SPACE>gj <C-n>
  nmap <buffer> <SPACE>gk <C-p>
  nmap <buffer> <SPACE>vo <
  nmap <buffer> <SPACE>vc >
  nmap <buffer><silent> q :quit<CR>
'''

[[plugins]]
repo = 'b0o/incline.nvim'
hook_add = '''
lua << EOF

require('incline').setup {
  render = "basic",
  debounce_threshold = {
    falling = 50,
    rising = 10
  },
  hide = {
    focused_win = false,
  },
  highlight = {
    groups = {
      InclineNormal = "IncSearch",
      InclineNormalNC = "Visual"
    },
  },
  ignore = {
    buftypes = "special",
    filetypes = {},
    floating_wins = true,
    unlisted_buffers = true,
    wintypes = "special",
  },
  window = {
    margin = {
      horizontal = {
        left = 1,
        right = 1
      },
      vertical = {
        bottom = 0,
        top = 1
      },
    },
    options = {
      signcolumn = "no",
      wrap = false
    },
    padding = {
      left = 1,
      right = 1
    },
    padding_char = " ",
    placement = {
      horizontal = "right",
      vertical = "top",
    },
    width = "fit",
    winhighlight = {
      active = {
        EndOfBuffer = "None",
        Normal = "InclineNormal",
        Search = "None"
      },
      inactive = {
        EndOfBuffer = "None",
        Normal = "InclineNormalNC",
        Search = "None"
      }
    },
    zindex = 50,
  },
}

EOF
'''

[[plugins]]
repo = 'hoob3rt/lualine.nvim'
hook_add = '''
lua << EOF

lualine_config = {}
lualine_config.width_small = 50

lualine_config.indent_type = function()
  if vim.fn.winwidth(0) < lualine_config.width_small then
    return ''
  end

  return vim.fn["spatab#GetDetectName"]()
end

lualine_config.current_function = function()
  local current_func = vim.b.lsp_current_function
  if not current_func then
    return ""
  end

  winwidth = vim.fn.winwidth("$")
  if string.len(current_func) > winwidth - 50 then
    return ""
  end
  
  return current_func
end

lualine_config.file_fullpath = function()
  return vim.fn.expand("%:p")
end

lualine_config.file_of_lines = function()
  return vim.fn.line("$")
end

lualine_config.git_branch = function()
  local branch = vim.fn["gina#component#repo#branch"]()
  if branch == "" then
    return ""
  end

  return " " .. branch
end

lualine_config.mode = function()
  return vim.api.nvim_get_mode().mode
end

lualine_config.git_diff_status = function()
  if vim.b.gitsigns_status then
    return vim.b.gitsigns_status
  end

  local hunks = vim.fn["GitGutterGetHunkSummary"]()
  local status = {
    added = hunks[1],
    changed = hunks[2],
    removed = hunks[3],
  }

  local added, changed, removed = status.added, status.changed, status.removed
  local status_txt = {}
  if added   and added   > 0 then
    table.insert(status_txt, '%#StatusLineInfoText#+'..added)
  end
  if changed and changed > 0 then
    table.insert(status_txt, '%#StatusLineWarningText#~'..changed)
  end
  if removed and removed > 0 then
    table.insert(status_txt, '%#StatusLineErrorText#-'..removed)
  end
  return table.concat(status_txt, ' ')
end

lualine_config.diagnostics = function()
  local counter = {}
  counter.error = vim.diagnostic.get(0, {severity = vim.diagnostic.severity.ERROR})
  counter.warning = vim.diagnostic.get(0, {severity = vim.diagnostic.severity.WARN})
  counter.info = vim.diagnostic.get(0, {severity = vim.diagnostic.severity.INFO})
  counter.hint = vim.diagnostic.get(0, {severity = vim.diagnostic.severity.HINT})

  local s = ""
  if counter.error ~= 0 then
    s = s .. " %#StatusLineErrorText#" .. counter.error
  end

  if counter.warning ~= 0 then
    s = s .. " %#StatusLineWarningText#" .. counter.warning
  end

  if counter.info ~= 0 then
    s = s .. " %#StatusLineInfoText#" .. counter.info
  end

  if counter.hint ~= 0 then
    s = s .. " H" .. counter.hint
  end

  return s
end

function custom_theme()
  local colors = {
    blue   = '#61afef',
    green  = '#98c379',
    purple = '#c678dd',
    red1   = '#e06c75',
    red2   = '#be5046',
    yellow = '#e5c07b',
    fg     = '#abb2bf',
    bg     = '#060811',
    gray1  = '#5c6370',
    gray2  = '#163821',
    gray3  = '#3e4452',
  }

  local normal = { fg = colors.fg, bg = colors.bg }
  return {
    normal = {
      a = normal,
      b = normal,
      c = normal,
    },
    inactive = {
      c = { fg = colors.gray1, bg = colors.bg },
    },
  }
end

require'lualine'.setup {
  options = {
    icons_enabled = true,
    theme = custom_theme(),
    component_separators = { left = '', right = ''},
    section_separators = '',
    disabled_filetypes = {'defx'},
    always_divide_middle = true,
    globalstatus=true,
  },
  sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = {
      lualine_config.git_branch,
      lualine_config.git_diff_status,
      -- lualine_config.current_function,
      {
        "aerial",
        sep = ' > ',
        depth = nil,
        dense = true,
        dense_sep = '.',
      },
    },
    lualine_x = {
      'diagnostics',
      'encoding',
      lualine_config.indent_type,
      'fileformat',
      {
        'filetype',
        colored = true,
        icon_only = true,
      },
    },
    lualine_y = {},
    lualine_z = {}
  },
  inactive_sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = {
      {
        'filename',
        file_status = true,
        path = 1,
        shorting_target = 0,
      }
    },
    lualine_x = {},
    lualine_y = {},
    lualine_z = {},
  },
  tabline = {},
  extensions = {},
}

EOF
'''

[[plugins]]
repo = 'anuvyklack/pretty-fold.nvim'
hook_add = '''
lua << EOF

require('pretty-fold').setup({
   sections = {
      left = {
         'content',
      },
      right = {
         ' ', 'number_of_folded_lines', ': ', 'percentage', ' ',
         function(config) return config.fill_char:rep(3) end
      }
   },
   fill_char = ' ',
   remove_fold_markers = true,
   keep_indentation = true,
   -- Possible values:
   -- "delete" : Delete all comment signs from the fold string.
   -- "spaces" : Replace all comment signs with equal number of spaces.
   -- false    : Do nothing with comment signs.
   process_comment_signs = 'spaces',
   comment_signs = {},
   stop_words = {
      '@brief%s*', -- (for C++) Remove '@brief' and all spaces after.
   },
   add_close_pattern = true,
   matchup_patterns = {
      {  '{', '}' },
      { '%(', ')' },
      { '%[', ']' },
   },
   ft_ignore = { 'neorg' },
})

require('pretty-fold.preview').setup()

EOF
'''

[[plugins]]
repo = 'j-hui/fidget.nvim'
hook_add = '''
lua require'fidget'.setup{}
'''

[[plugins]]
repo = 'nvim-lua/lsp-status.nvim'

[[plugins]]
repo = 'neovim/nvim-lspconfig'
hook_add = '''
lua << EOF
  local border = {
        {"╭", "FloatBorder"},
        {"─", "FloatBorder"},
        {"╮", "FloatBorder"},
        {"│", "FloatBorder"},
        {"╯", "FloatBorder"},
        {"─", "FloatBorder"},
        {"╰", "FloatBorder"},
        {"│", "FloatBorder"},
  }
  local orig_util_open_floating_preview = vim.lsp.util.open_floating_preview
  function vim.lsp.util.open_floating_preview(contents, syntax, opts, ...)
    opts = opts or {}
    opts.border = opts.border or border
    return orig_util_open_floating_preview(contents, syntax, opts, ...)
  end

  local lsp_status = require('lsp-status')
  lsp_status.register_progress()

  float_border = { "╭", "─", "╮", "│", "╯", "─", "╰", "│" }
  local on_attach = function (client, bufnr)
    local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end

    local opts = { noremap=true, silent=true }
    buf_set_keymap('n', '<Space>mgd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
    -- buf_set_keymap('n', '<Space>mpd', '<cmd>lua require("lspsaga.provider").preview_definition()<CR>', opts)
    buf_set_keymap('n', '<Space>mgi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
    buf_set_keymap('n', '<Space>mh', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
    buf_set_keymap('n', '<Space>mca', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
    buf_set_keymap('n', '<Space>mr', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
    -- buf_set_keymap('n', '<Space>mf', '<cmd>lua require("lspsaga.provider").lsp_finder()<CR>', opts)
    buf_set_keymap('n', '<Space>ek', '<cmd>lua vim.diagnostic.goto_prev()<CR>', opts)
    buf_set_keymap('n', '<Space>ej', '<cmd>lua vim.diagnostic.goto_next()<CR>', opts)

    buf_set_keymap('n', '<Space>mic', '<cmd>lua vim.lsp.buf.incoming_calls()<CR>', opts)
    buf_set_keymap('n', '<Space>moc', '<cmd>lua vim.lsp.buf.outgoing_calls()<CR>', opts)

    -- not work?
    -- buf_set_keymap('n', '<C-f>', '<cmd>lua require("lspsaga.action").smart_scroll_with_saga(1)<CR>', opts)
    -- buf_set_keymap('n', '<C-b>', '<cmd>lua require("lspsaga.action").smart_scroll_with_saga(-1)<CR>', opts)

    lsp_status.on_attach(client, bufnr)
    require'lsp_signature'.on_attach({
      bind = true,
      doc_lines = 10,
      floating_window = true,
      fix_pos = true,
      hint_enable = true,
      hint_prefix = "> ",
      hint_scheme = "String",
      use_lspsaga = false,
      hi_parameter = "Search",
      max_height = 12,
      max_width = 120,
      handler_opts = {
        border = "rounded"
      },
      extra_trigger_chars = {}
    })
  end

  local lsp_installer = require("nvim-lsp-installer")
  local comp = require('cmp_nvim_lsp')

  lsp_installer.on_server_ready(function(server)
    local opts = {
      on_attach = on_attach,
      capabilities = comp.update_capabilities(vim.lsp.protocol.make_client_capabilities()),
    }

    server:setup(opts)
  end)

  vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
   vim.lsp.diagnostic.on_publish_diagnostics, {
     virtual_text = true,
     signs = false,
   }
  )
EOF
'''

[[plugins]]
repo = 'williamboman/nvim-lsp-installer'

[[plugins]]
repo = 'phaazon/hop.nvim'
hook_add = '''
nnoremap <silent> <Space>jj <cmd>HopChar2<CR>
lua require'hop'.setup()
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
hook_add = '''
let g:EasyMotion_smartcase = 1

map f <Plug>(easymotion-bd-fl)
map t <Plug>(easymotion-bd-tl)
'''

[[plugins]]
repo = 'andymass/vim-matchup'
hook_add = '''
  augroup matchup_matchparen_highlight
    autocmd!
    autocmd ColorScheme * highlight MatchParen ctermfg=none
  augroup END

  let g:matchup_matchparen_offscreen = {'method': 'popup'}
'''

[[plugins]]
repo = 'kana/vim-operator-replace'
hook_add = '''
map R <Nop>
map R <Plug>(operator-replace)
'''

[[plugins]]
repo = 'rhysd/vim-operator-surround'
hook_add = '''
nmap s <Nop>
xmap s <Nop>

nmap <silent>sa <Plug>(operator-surround-append)
nmap <silent>sd <Plug>(operator-surround-delete)
nmap <silent>sr <Plug>(operator-surround-replace)
'''

[[plugins]]
repo = 'kana/vim-operator-user'
hook_add = '''
nmap <silent>sc <Plug>(operator-camelize)gv
nmap <silent>sC <Plug>(operator-decamelize)gv
nmap <silent>se <Plug>(operator-html-escape)
nmap <silent>sE <Plug>(operator-html-unescape)

xmap <silent>sc <Plug>(operator-camelize)gv
xmap <silent>sC <Plug>(operator-decamelize)gv
xmap <silent>se <Plug>(operator-html-escape)
xmap <silent>sE <Plug>(operator-html-unescape)

let g:operator#surround#blocks = {
  \ '-' : [
  \ {'block' : ['(', ')'],
  \ 'motionwise' : ['char', 'line', 'block'], 'keys' : ['b'] },
  \ {'block' : ['{', '}'],
  \ 'motionwise' : ['char', 'line', 'block'], 'keys' : ['B'] },
  \ {'block' : ["'", "'"],
  \ 'motionwise' : ['char', 'line', 'block'], 'keys' : ['q'] },
  \ {'block' : ['"', '"'],
  \ 'motionwise' : ['char', 'line', 'block'], 'keys' : ['Q'] }
  \ ]}
'''

[[plugins]]
repo = 'tpope/vim-repeat'

[[plugins]]
repo = 't9md/vim-textmanip'
hook_add = '''
xmap <Space>d <Plug>(textmanip-duplicate-down)
xmap <Space>D <Plug>(textmanip-duplicate-up)

xmap <C-j> <Plug>(textmanip-move-down)
xmap <C-k> <Plug>(textmanip-move-up)
xmap <C-h> <Plug>(textmanip-move-left)
xmap <C-l> <Plug>(textmanip-move-right)
'''

[[plugins]]
repo = 'deathlyfrantic/vim-textobj-blanklines'

[[plugins]]
repo = 'kana/vim-textobj-entire'

[[plugins]]
repo = 'kana/vim-textobj-indent'

[[plugins]]
repo = 'sgur/vim-textobj-parameter'
hook_add = '''
let g:vim_textobj_parameter_mapping = 'a'
'''

[[plugins]]
repo = 'lucapette/vim-textobj-underscore'

[[plugins]]
repo = 'kana/vim-textobj-user'

[[plugins]]
repo = 'bronson/vim-visual-star-search'

[[plugins]]
repo = 'w0rp/ale'
hook_add = '''
nnoremap <silent> <SPACE>af :<C-u>silent! ALEFix<CR>
augroup custom-ale
  autocmd!
  autocmd FileType go let b:ale_fix_on_save = 1
augroup END

let g:ale_sign_column_always   = 1
let g:ale_lint_on_insert_leave = 1
let g:ale_lint_on_text_changed = 'normal'
let g:ale_enabled              = 0
let g:ale_virtualtext_cursor   = 1
let g:ale_virtualtext_prefix   = ' >> '

let g:ale_sign_error           = '>>'
let g:ale_sign_warning         = '>>'
let g:ale_echo_msg_error_str   = 'E'
let g:ale_echo_msg_warning_str = 'W'

let g:ale_echo_msg_format   = '[%severity%] %code%: %s | %linter%'

function! AleStatus()
  if !get(b:, 'ale_enabled', 0) && !g:ale_enabled
    return ''
  endif

  let counts = ale#statusline#Count(bufnr(''))

  if !counts['total']
    return 'OK'
  endif

  return printf('E%d W%d', counts[0], counts[1])
endfunction

function! s:parseCfnLint(line) abort
  let words = split(a:line, ":")
  return {"text": words[6], "lnum": words[1], "col": words[2], "type": "W"}
endfunction

call ale#linter#Define('yaml', {
  \ 'name': 'cfn-lint',
  \ 'executable': 'cfn-lint',
  \ 'command': 'cfn-lint -f parseable %t',
  \ 'callback': {buffer, lines -> map(lines, 's:parseCfnLint(v:val)')},
  \ })

let g:ale_linters = {
  \ 'python': ['flake8', 'mypy', 'bandit'],
  \ 'javascript': ['eslint'],
  \ 'php': ['phpcs'],
  \ 'css': ['stylelint'],
  \ 'xhtml': ['tidy'],
  \ 'cs': ['OmniSharp'],
  \ 'swift': ['swiftlint'],
  \ 'kotlin': ['ktlint'],
  \ 'go': ['golangci-lint'],
  \ 'yaml': ['yamllint', 'cfn-lint'],
  \ }

let g:ale_type_map = {'flake8': {'ES': 'WS'}}
let g:ale_css_stylelint_options='-c stylelint'
let g:ale_python_mypy_options='--ignore-missing-imports'
let g:ale_python_flake8_options='--ignore=E501'

let g:ale_html_tidy_options='-config ~/.tidy_linter -e'
let g:ale_php_phpcs_standard='PSR2'
let g:ale_linter_aliases = {'xhtml': 'html'}

let g:ale_fixers = {
  \ 'html': [
  \   {buffer, lines -> {
  \   'command': 'tidy -config ~/.tidy_fix %s'}}
  \ ],
  \ 'xhtml': [
  \   {buffer, lines -> {
  \   'command': 'tidy -config ~/.tidy_fix %s'}}
  \ ],
  \ 'javascript': [
  \   {buffer, lines -> {
  \   'command': 'eslint --config ~/.eslintrc.js --fix %t',
  \   'read_temporary_file': 1}}
  \ ],
  \ 'css': [
  \   {buffer, lines -> {
  \   'command': 'stylelint -c stylelint --fix %t',
  \   'read_temporary_file': 1}},
  \   {buffer, lines -> {
  \   'command': 'csscomb -c ~/.csscomb.json %s'}}
  \ ],
  \ 'php': [
  \   {buffer, lines -> {
  \   'command': 'phpcbf --standard=PSR2 %t',
  \   'read_temporary_file': 1}}
  \ ],
  \ 'python': [
  \   'isort',
  \   {buffer, lines -> {
  \   'command': 'black %t',
  \   'read_temporary_file': 1}}
  \ ],
  \ 'kotlin': [
  \   {buffer, lines -> {
  \   'command': 'ktlint -F %t',
  \   'read_temporary_file': 1}}
  \ ],
  \ 'markdown': [
  \   {buffer, lines -> {
  \   'command': 'textlint -c ~/.config/textlintrc -o /dev/null --fix --no-color --quiet %t',
  \   'read_temporary_file': 1}}
  \ ],
  \ 'sql': [
  \   {buffer, lines -> {
  \   'command': 'sqlformat --reindent --keywords upper -s %t | sql-formatter-cli -o %t',
  \   'read_temporary_file': 1}}
  \ ],
  \ 'go': ['gofmt', 'goimports'],
  \ 'svelte': ['prettier'],
  \ 'json': ['jq'],
  \ }
" let g:ale_fix_on_save = 1

highlight link ALEWarningSign SpellCap
'''

[[plugins]]
repo = 'scrooloose/nerdcommenter'
hook_add = '''
let g:NERDCommentEmptyLines      = 1
let g:NERDTrimTrailingWhitespace = 1
let g:NERDSpaceDelims            = 1
let g:NERDCompactSexyComs        = 1
let g:NERDDefaultAlign           = 'left'

let g:NERDCustomDelimiters = {
    \ 'wsh': { 'left': "'" },
\ }

map <SPACE>cn <plug>NERDCommenterNested
map <SPACE>cy <plug>NERDCommenterYank
map <SPACE>cm <plug>NERDCommenterMinimal
map <SPACE>cc <plug>NERDCommenterToggle
map <SPACE>cs <plug>NERDCommenterSexy
map <SPACE>ci <plug>NERDCommenterToEOL
map <SPACE>cA <plug>NERDCommenterAppend
map <SPACE>cx <plug>NERDCommenterAltDelims
'''

[[plugins]]
repo = 'deresmos/pytest-vim-compiler'

[[plugins]]
repo = 'sheerun/vim-polyglot'
build = './build'
hook_add = '''
  augroup my-pug-augroup
    autocmd!
    " autocmd FileType pug setlocal syntax=css
  augroup END
'''

[[plugins]]
repo = 'deresmos/vim-snippets'

[[plugins]]
repo = 'stevearc/aerial.nvim'
hook_add = '''
lua << EOF
-- Call the setup function to change the default behavior
require("aerial").setup({
  backends = { "treesitter", "lsp", "markdown" },
  close_behavior = "auto",
  default_bindings = true,
  default_direction = "prefer_right",
  disable_max_lines = 10000,
  disable_max_size = 10000000,
  filter_kind = {
    "Class",
    "Constructor",
    "Enum",
    "Function",
    "Interface",
    "Module",
    "Method",
    "Struct",
    "Variable",
  },
  highlight_mode = "split_width",
  highlight_closest = true,
  highlight_on_hover = false,
  highlight_on_jump = 300,
  icons = {},
  ignore = {
    unlisted_buffers = true,
    filetypes = {},
    buftypes = "special",
    wintypes = "special",
  },
  link_folds_to_tree = false,
  link_tree_to_folds = true,
  manage_folds = false,
  max_width = { 40, 0.2 },
  width = nil,
  min_width = 30,
  nerd_font = "auto",
  on_attach = nil,
  open_automatic = false,
  placement_editor_edge = false,
  post_jump_cmd = "normal! zz",
  close_on_select = false,
  show_guides = false,
  update_events = "TextChanged,InsertLeave",
  guides = {
    mid_item = "├─",
    last_item = "└─",
    nested_top = "│ ",
    whitespace = "  ",
  },
  float = {
    border = "rounded",
    relative = "editor",
    max_height = 0.9,
    height = nil,
    min_height = { 8, 0.5 },
    override = function(conf)
      return conf
    end,
  },
  lsp = {
    diagnostics_trigger_update = true,
    update_when_errors = true,
    update_delay = 300,
  },
  treesitter = {
    update_delay = 300,
  },
  markdown = {
    update_delay = 300,
  },
})
EOF
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
build = ':TSUpdate'

[[plugins]]
repo = 'romgrk/nvim-treesitter-context'
build = ':TSUpdate'
